# ------- Well Count Analysis and Graphs -------
# Danielle Tadych, Spring 2022

# The purpose of this code is to make graphs for well depths with respect to groundwater regulation,
#   access to surface water, and georegions

# More specifically,
# - Well Density (cumulative number of wells) over time
# - max screen depth over time (Casing_DEP vs Installed)
# - Number of new wells installed over time

# To run this code you first need files generated by Spatial_Analysis_Wells_FinalGeoreg.py

# %% Load the packages
from cProfile import label
from operator import ge
from optparse import Values
import os
from geopandas.tools.sjoin import sjoin
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
from matplotlib.colors import ListedColormap
import datetime
from matplotlib.transforms import Bbox
import seaborn as sns
import numpy as np
import pandas as pd
from shapely.geometry import box
import geopandas as gp
#import earthpy as et
import scipy.stats as sp
# %% Assign Data paths
datapath = '../Data'
outputpath = '../Data/Output_files/'
shapepath = '../Data/Shapefiles/'

# %% Creating colors
c_1 = '#8d5a99' # Reservation
c_2 = "#d7191c" # Regulated with CAP (Water Category Color)
c_3 = '#e77a47' # Regulated without CAP (Water Category Color)
c_4 = '#2cbe21' # Lower CO River - SW (Water Category Color)
c_5 = '#2f8c73' # Upper CO River - Mixed (Water Category Color)
c_6 = '#6db7e8' # SE - GW
c_7 = '#165782' # NW - GW (Water Category color)
c_8 = '#229ce8' # SC - GW
c_9 = '#1f78b4' # NE - GW
c_10 = '#41bf9e' # N - Mixed
c_11 = '#7adec4' # C - Mixed
drought_color = '#ffa6b8'
wet_color = '#b8d3f2'


reg_colors = [c_2,c_7]
georeg_colors = [c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8,c_9,c_10,c_11]
SW_colors = [c_2,c_3,c_4,c_5,c_7]

bar_watercatc = [c_2,c_3,c_4,c_5,c_7]

# Color blind palette
# https://jacksonlab.agronomy.wisc.edu/2016/05/23/15-level-colorblind-friendly-palette/
blind =["#000000","#004949","#009292","#ff6db6","#ffb6db",
 "#490092","#006ddb","#b66dff","#6db6ff","#b6dbff",
 "#920000","#924900","#db6d00","#24ff24","#ffff6d"]

# Matching new map

cap = '#C6652B'
# noCAP = '#EDE461'
noCAP = '#CCC339'
GWdom = '#3B76AF'
mixed = '#6EB2E4'
swdom = '#469B76'
# %% --- Now making graphs for other things
# Re-read in after proper install date formatting, also had to fix NaN values in Regulation column
#       Note: had to go into excel and change the date from mm/dd/yy to mm/dd/yyyy
#             because date parser cutoff for older items is 1969
filename = 'Final_Static_geodatabase_waterwells.csv'
filepath = os.path.join(outputpath, filename)
print(filepath)
static_geo2 = pd.read_csv(filepath 
                          ,parse_dates=['INSTALLED']
                          )
static_geo2

# %% Only run this if date parser didn't work
static_geo2['INSTALLED'] = pd.to_datetime(static_geo2['INSTALLED'])
static_geo2['INSTALLED'].describe()
# %%
static_geo2['In_year'] = static_geo2['INSTALLED'].dt.year
static_geo2['In_year'].describe()

# %% Checking information about static_geo2

static_na = static_geo2[static_geo2['Regulation'].isna()]
print(static_na)

# %%
static_na['GEO_Region'].unique()

# %% 
Well_Depth = static_geo2[['WELL_DEPTH', 'INSTALLED', 'Combo_ID', 'In_year','GEOREGI_NU', 'Regulation', 'Water_CAT','WELL_TYPE_']]
#%%
Well_Depth

#%%
# Well_Depth.to_csv('../MergedData/Output_files/Final_WellDepth.csv')
#%%
# Well_Depth = pd.pivot_table(static_geo2, index=["In_year"], columns=["GEOREGI_NU"], values=["WELL_DEPTH"], dropna=False, aggfunc=np.mean)
Well_Depth = pd.pivot_table(static_geo2, index=["In_year"], columns=["Regulation"], values=["WELL_DEPTH"], dropna=False, aggfunc=np.mean)
state_depth = pd.pivot_table(static_geo2, index=["In_year"], values=["WELL_DEPTH"], dropna=False, aggfunc=np.mean)
Well_Depth.describe()

# %% Set shallow and drilling depths
shallow = 200
deep = 500

# %%
wd1 = static_geo2[(static_geo2["WELL_DEPTH"] > deep)]
wd2 = static_geo2[(static_geo2["WELL_DEPTH"] <= deep) & (static_geo2["WELL_DEPTH"] >= shallow)]
wd3 = static_geo2[(static_geo2["WELL_DEPTH"] < shallow)]

# st_wd1 = state_depth[(state_depth["WELL_DEPTH"] > deep)]
# st_wd2 = state_depth[(state_depth["WELL_DEPTH"] <= deep) & (static_geo2["WELL_DEPTH"] >= shallow)]
# st_wd3 = state_depth[(state_depth["WELL_DEPTH"] < shallow)]


# %%
wd1 = wd1.sort_values(by=['GEOREGI_NU'])
wd2 = wd2.sort_values(by=['GEOREGI_NU'])
wd3 = wd3.sort_values(by=['GEOREGI_NU'])

#%%
# wdc1 = pd.pivot_table(wd1, index=["In_year"], columns=["GEOREGI_NU"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
# wdc2 = pd.pivot_table(wd2, index=["In_year"], columns=["GEOREGI_NU"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
# wdc3 = pd.pivot_table(wd3, index=["In_year"], columns=["GEOREGI_NU"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)

# wdc1 = pd.pivot_table(wd1, index=["In_year"], columns=["GEO_Region"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
# wdc2 = pd.pivot_table(wd2, index=["In_year"], columns=["GEO_Region"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
# wdc3 = pd.pivot_table(wd3, index=["In_year"], columns=["GEO_Region"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)

wdc1_reg = pd.pivot_table(wd1, index=["In_year"], columns=["Regulation"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc2_reg = pd.pivot_table(wd2, index=["In_year"], columns=["Regulation"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc3_reg = pd.pivot_table(wd3, index=["In_year"], columns=["Regulation"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)

wdc1_wc = pd.pivot_table(wd1, index=["In_year"], columns=["Water_CAT"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc2_wc = pd.pivot_table(wd2, index=["In_year"], columns=["Water_CAT"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc3_wc = pd.pivot_table(wd3, index=["In_year"], columns=["Water_CAT"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)

# %%
st_wdc1 = pd.pivot_table(wd1, index=["In_year"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
st_wdc2 = pd.pivot_table(wd2, index=["In_year"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
st_wdc3 = pd.pivot_table(wd3, index=["In_year"], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
st_wdc1

# %% Exempt/non-exempt added
wdc1_reg_ex = pd.pivot_table(wd1, index=["In_year"], columns=["Regulation",'WELL_TYPE_'], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc2_reg_ex = pd.pivot_table(wd2, index=["In_year"], columns=["Regulation",'WELL_TYPE_'], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc3_reg_ex = pd.pivot_table(wd3, index=["In_year"], columns=["Regulation",'WELL_TYPE_'], values=['WELL_DEPTH'], dropna=False, aggfunc=len)

wdc1_wc_ex = pd.pivot_table(wd1, index=["In_year"], columns=["Water_CAT",'WELL_TYPE_'], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc2_wc_ex = pd.pivot_table(wd2, index=["In_year"], columns=["Water_CAT",'WELL_TYPE_'], values=['WELL_DEPTH'], dropna=False, aggfunc=len)
wdc3_wc_ex = pd.pivot_table(wd3, index=["In_year"], columns=["Water_CAT",'WELL_TYPE_'], values=['WELL_DEPTH'], dropna=False, aggfunc=len)

#%% Exporting the Depth categories
wdc1_reg.to_csv(outputpath+'Final_Welldepth_regulation' + str(deep) + 'plus.csv')
wdc2_reg.to_csv(outputpath+'Final_Welldepth_regulation' + str(shallow) + 'to' + str(deep) + '.csv')
wdc3_reg.to_csv(outputpath+'Final_Welldepth_regulation' + str(shallow) + 'minus.csv')

wdc1_wc.to_csv(outputpath+'Final_Welldepth_sw' + str(deep) + 'plus.csv')
wdc2_wc.to_csv(outputpath+'Final_Welldepth_sw' + str(shallow) + 'to' + str(deep) + '.csv')
wdc3_wc.to_csv(outputpath+'Final_Welldepth_sw' + str(shallow) + 'minus.csv')

wdc1_reg_ex.to_csv(outputpath+'Final_Welldepth_regulation_exemptstatus' + str(deep) + 'plus.csv')
wdc2_reg_ex.to_csv(outputpath+'Final_Welldepth_regulation_exemptstatus' + str(shallow) + 'to' + str(deep) + '.csv')
wdc3_reg_ex.to_csv(outputpath+'Final_Welldepth_regulation_exemptstatus' + str(shallow) + 'minus.csv')

wdc1_wc_ex.to_csv(outputpath+'Final_Welldepth_sw_exemptstatus' + str(deep) + 'plus.csv')
wdc2_wc_ex.to_csv(outputpath+'Final_Welldepth_sw_exemptstatus' + str(shallow) + 'to' + str(deep) + '.csv')
wdc3_wc_ex.to_csv(outputpath+'Final_Welldepth_sw_exemptstatus' + str(shallow) + 'minus.csv')

# %% Now just new wells for general and density calculations
new_wells = pd.pivot_table(static_geo2, index=["In_year"], columns=["GEOREGI_NU"], values=["INSTALLED"], dropna=False, aggfunc=len)
new_wells_reg = pd.pivot_table(static_geo2, index=["In_year"], columns=["Regulation"], values=["INSTALLED"], dropna=False, aggfunc=len)
new_wells_watercat = pd.pivot_table(static_geo2, index=["In_year"], columns=["Water_CAT"], values=["INSTALLED"], dropna=False, aggfunc=len)
new_wells_reg
new_wells_watercat
# %%
new_wells.to_csv(outputpath+'Final_NewWells.csv')
new_wells_reg.to_csv(outputpath+'Final_NewWells_regulation.csv')
new_wells_watercat.to_csv(outputpath+'Final_NewWells_watercat.csv')

# %% ---- Fancier Analyses ----
# Calculating well densities
new_wells2 = pd.read_csv(outputpath+'/Final_NewWells.csv',
                        header=1, index_col=0)
new_wells2
#%%
new_wells2 = new_wells2.reset_index()
new_wells2 = new_wells2.iloc[1:, :]
#new_wells2 = new_wells2.rename(columns = {'GEOREGI_NU':'Year'})
new_wells2 = new_wells2.set_index('GEOREGI_NU')
new_wells2

# %%
new_wells_reg2 = pd.read_csv(outputpath+'Final_NewWells_regulation.csv',
                        header=2,
                        names = ['R','Res','U']
                        , index_col=0)
# new_wells_reg2 = new_wells_reg2.reset_index()
new_wells_reg2 = new_wells_reg2.iloc[1:, :]
# new_wells_reg2 = new_wells_reg2.set_index('Year')
new_wells_reg2

# %%
new_wells_watercat2 = pd.read_csv(outputpath+'Final_NewWells_watercat.csv',
                        header=1,
                        names = ['CAP','GW','Mix','No_CAP','Res','SW']
                        , index_col=0)
# new_wells_watercat2 = new_wells_watercat2.reset_index()
new_wells_watercat2 = new_wells_watercat2.iloc[1:, :]
# new_wells_watercat2 = new_wells_watercat2.set_index('Year')
new_wells_watercat2

# %%
# Reading in the shapefile
# GEOREG.to_file('../MergedData/Output_files/Georegions_3col.shp')
# filename_georeg = "Final_Georegions.shp"
# filepath = os.path.join(shapepath, filename_georeg)

filename_georeg = 'georeg_reproject_fixed.shp'
filepath = os.path.join(shapepath+filename_georeg)
georeg = gp.read_file(filepath)
# %% Calculate the region area
# to double check the coordinate system is in meters, georeg.crs
# 
# https://gis.stackexchange.com/questions/218450/getting-polygon-areas-using-geopandas
# tost["area"] = tost['geometry'].area/ 10**6
georeg = georeg.to_crs(epsg=3857)
georeg.crs

# %%
georeg['area'] = georeg.geometry.area/10**6
georeg

# %%
# georeg2 = pd.DataFrame(tost)
georeg2 = pd.DataFrame(georeg)
# %%
#georeg2.to_csv('../MergedData/Output_files/georegions_area.csv')

#%%
georeg_area = georeg2[['GEOREGI_NU','area']]
georeg_area.info()

# %%
georeg_area = georeg_area.set_index('GEOREGI_NU')
georeg_area = georeg_area.transpose()
georeg_area

# %% Area for other categories
georeg_area_reg = pd.pivot_table(georeg2, columns=["Regulation"], values=["area"], dropna=False, aggfunc=np.sum)
# del georeg_area_reg['Res']
georeg_area_reg

# %%
georeg_area_watercat = pd.pivot_table(georeg2, columns=["Water_CAT"], values=["area"], dropna=False, aggfunc=np.sum)
# del georeg_area_watercat['Res']
georeg_area_watercat
# %% Densities for new wells
well_densities = new_wells2/georeg_area.values[0,:]
# well_densities = new_wells/georeg_area.values[0,:]
well_densities

# %% Densities for regulated regions
well_densities_reg = new_wells_reg2/georeg_area_reg.values[0,:]
well_densities_reg

# %% Densities for SW
well_densities_watercat = new_wells_watercat2/georeg_area_watercat.values[0,:]
well_densities_watercat.sum()

# %% By depth for regulated or water category, depending on what I turned on above
dens_wdc1_reg= wdc1_reg/georeg_area_reg.values[0,:]
dens_wdc2_reg= wdc2_reg/georeg_area_reg.values[0,:]
dens_wdc3_reg= wdc3_reg/georeg_area_reg.values[0,:]

dens_wdc1_wc= wdc1_wc/georeg_area_watercat.values[0,:]
dens_wdc2_wc= wdc2_wc/georeg_area_watercat.values[0,:]
dens_wdc3_wc= wdc3_wc/georeg_area_watercat.values[0,:]

dens_wdc1_wc
print(dens_wdc1_wc.sum())

# %% Well densities but with exemption status
df = pd.DataFrame(wdc1_reg_ex.sum())
df = df.transpose()
df
# %%
georeg_area_reg_dens = pd.DataFrame(df,index=df.index)
# georeg_area_reg_dens = georeg_area_reg_dens.transpose()
# %%
georeg_area_reg_dens.iloc[0,0:3] = georeg_area_reg.iloc[0,0]
georeg_area_reg_dens.iloc[0,3:6] = georeg_area_reg.iloc[0,1]
georeg_area_reg_dens.iloc[0,6:9] = georeg_area_reg.iloc[0,2]
georeg_area_reg_dens

# %% 
dens_wdc1_reg_ex= wdc1_reg_ex/georeg_area_reg_dens.values[0,:]
dens_wdc2_reg_ex= wdc2_reg_ex/georeg_area_reg_dens.values[0,:]
dens_wdc3_reg_ex= wdc3_reg_ex/georeg_area_reg_dens.values[0,:]
dens_wdc3_reg_ex.sum()
# %%
df = pd.DataFrame(wdc1_wc_ex.sum())
df = df.transpose()
df
# %%
georeg_area_watercat_dens = pd.DataFrame(df,index=df.index)
georeg_area_watercat_dens.iloc[0,0:3] = georeg_area_watercat.iloc[0,0]
georeg_area_watercat_dens.iloc[0,3:6] = georeg_area_watercat.iloc[0,1]
georeg_area_watercat_dens.iloc[0,6:9] = georeg_area_watercat.iloc[0,2]
georeg_area_watercat_dens.iloc[0,9:12] = georeg_area_watercat.iloc[0,3]
georeg_area_watercat_dens.iloc[0,12:15] = georeg_area_watercat.iloc[0,4]
georeg_area_watercat_dens.iloc[0,15:18] = georeg_area_watercat.iloc[0,5]
georeg_area_watercat_dens

# %%
dens_wdc1_wc_ex= wdc1_wc_ex/georeg_area_watercat_dens.values[0,:]
dens_wdc2_wc_ex= wdc2_wc_ex/georeg_area_watercat_dens.values[0,:]
dens_wdc3_wc_ex= wdc3_wc_ex/georeg_area_watercat_dens.values[0,:]
dens_wdc3_wc_ex.info()

#%% Exporting the well densities
dens_wdc1_reg.to_csv(outputpath+'FinalDensities_Welldepth_regulation' + str(deep) + 'plus.csv')
dens_wdc2_reg.to_csv(outputpath+'FinalDensities_Welldepth_regulation' + str(shallow) + 'to' + str(deep) + '.csv')
dens_wdc3_reg.to_csv(outputpath+'FinalDensities_Welldepth_regulation' + str(shallow) + 'minus.csv')

dens_wdc1_wc.to_csv(outputpath+'FinalDensities_Welldepth_sw' + str(deep) + 'plus.csv')
dens_wdc2_wc.to_csv(outputpath+'FinalDensities_Welldepth_sw' + str(shallow) + 'to' + str(deep) + '.csv')
dens_wdc3_wc.to_csv(outputpath+'FinalDensities_Welldepth_sw' + str(shallow) + 'minus.csv')

dens_wdc1_reg_ex.to_csv(outputpath+'FinalDensities_Welldepth_regulation_exemptstatus' + str(deep) + 'plus.csv')
dens_wdc2_reg_ex.to_csv(outputpath+'FinalDensities_Welldepth_regulation_exemptstatus' + str(shallow) + 'to' + str(deep) + '.csv')
dens_wdc3_reg_ex.to_csv(outputpath+'FinalDensities_Welldepth_regulation_exemptstatus' + str(shallow) + 'minus.csv')

dens_wdc1_wc_ex.to_csv(outputpath+'FinalDensities_Welldepth_sw_exemptstatus' + str(deep) + 'plus.csv')
dens_wdc2_wc_ex.to_csv(outputpath+'FinalDensities_Welldepth_sw_exemptstatus' + str(shallow) + 'to' + str(deep) + '.csv')
dens_wdc3_wc_ex.to_csv(outputpath+'FinalDensities_Welldepth_sw_exemptstatus' + str(shallow) + 'minus.csv')


# %% ------------------------------------------------------------------------
# This whole thing was to double check if my numbers were correct, skip this.
well_densities_reg_total = well_densities_reg.sum()
well_densities_reg_total

# %%
# new_wells_reg_total = new_wells_reg2.sum()
# new_wells_reg_total = pd.pivot_table(new_wells_reg2, index = dropna=False, aggfunc=np.sum)
new_wells_reg_total = pd.DataFrame()
new_wells_reg_total['R'] = new_wells_reg2['R'].sum()
new_wells_reg_total['U'] = new_wells_reg2['U'].sum()
new_wells_reg_total

# %% df.loc['Column_Total']= df.sum(numeric_only=True, axis=0)
new_wells_reg_total = new_wells_reg2
new_wells_reg_total.loc['Column_Total']= new_wells_reg_total.sum(numeric_only=True, axis=0)
# new_wells_reg_total = new_wells_reg_total.loc['Column_Total']
new_wells_reg_total

# %%
test = pd.DataFrame(new_wells_reg2.sum(numeric_only=True, axis=0))
test = test.transpose()
test
# %%
test_welldensit_reg = test/georeg_area_reg.values[0,:]
test_welldensit_reg
# --------------------------------------------------------------------------

# %%
well_densities['3'].plot()

# %%
well_densities1 = well_densities.reset_index()
well_densities1['GEOREGI_NU'] = pd.to_numeric(well_densities1['GEOREGI_NU'])
well_densities1['GEOREGI_NU'] = well_densities1['GEOREGI_NU'].astype(int)
well_densities1.set_index('GEOREGI_NU', inplace=True)
well_densities1.info()

# %% -- Linear regression --
# This is testing whether or not the slope is positive or negative (2-way)
#       For our purposes, time is the x variable and y is
#       1. Water Levels 
#       2. Number of Wells
#       3. Well Depths

# Actual documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html
# Tutorial from https://mohammadimranhasan.com/linear-regression-of-time-series-data-with-pandas-library-in-python/

# 1.  For Water Levels - See Spatial_Analysis_Wells_FinalGeoreg.py

# %% 2. For New Wells
ds = new_wells_reg2
data_type = "New Wells"
betterlabels = ['Regulated','Unregulated'] 
min_yr = 1993
mx_yr = 2019
# Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

# f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
# columns = ds.columns
# column_list = ds.columns.tolist()

# -- For Multiple years --
Name = "Linear Regression during Drought years for " + data_type
# wetyrs = [2005, 2008, 2009, 2010, 2016, 2017, 2019]
# dryyrs = [2002, 2003, 2004, 2006, 2007, 2011, 2012, 2013, 2014, 2015, 2018]
dryyrs = [1975,1976,1977
          ,1981,1989,1990
          ,1996,1997,
          1999,2000,2001,2002,2003,2004
          ,2006,2007,2008,2009
          ,2011, 2012, 2013, 2014, 2015, 2016,2017,2018]

#f = ds[(ds.index == wetyrs)]

f = pd.DataFrame()
for i in dryyrs:
        wut = ds[(ds.index == i)]
        f = f.append(wut)
# print(f)
columns = ds.columns
column_list = ds.columns.tolist()
# ------------------------

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)
        
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()

stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','Regulated'], 2)
m2 = round(stats1.loc['slope','Unregulated'], 2)
yint1 = round(stats1.loc['int','Regulated'], 2)
yint2 = round(stats1.loc['int','Unregulated'], 2)
pval1 = round(stats1.loc['p_val', 'Regulated'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
f.plot(ax=ax,marker='o', ls='', label=betterlabels)
# ax.set_xlim(min_yr, mx_yr)
ax.set_title(data_type)
plt.figtext(0.95, 0.4, 'Regulated equation: y= '+str(m1)+'x + '+str(yint1))
plt.figtext(0.96, 0.35, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.6, 'Unregulated equation: y= '+str(m2)+'x + '+str(yint2))
plt.figtext(0.96, 0.55, 'p-value = ' + str(pval2))
ax.legend()
plt.savefig(outputpath+'Stats/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/'+Name+'.csv')

# %% 3. Well Depths
# == For Shallow ==
ds = wdc3
data_type = "Shallow Wells"
betterlabels = ['Regulated','Unregulated'] 
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()

stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','Regulated'], 2)
m2 = round(stats1.loc['slope','Unregulated'], 2)
yint1 = round(stats1.loc['int','Regulated'], 2)
yint2 = round(stats1.loc['int','Unregulated'], 2)
pval1 = round(stats1.loc['p_val', 'Regulated'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
f.plot(ax=ax,marker='o', ls='', label=betterlabels)
ax.set_title(data_type)
plt.figtext(0.95, 0.4, 'Regulated equation: y= '+str(m1)+'x + '+str(yint1))
plt.figtext(0.96, 0.35, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.6, 'Unregulated equation: y= '+str(m2)+'x + '+str(yint2))
plt.figtext(0.96, 0.55, 'p-value = ' + str(pval2))
ax.legend()
plt.savefig(outputpath+'Stats/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/'+Name+'.csv')

# == For Midrange ==
ds = wdc2
data_type = "Midrange Wells"
betterlabels = ['Regulated','Unregulated'] 
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)
        
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()

stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','Regulated'], 2)
m2 = round(stats1.loc['slope','Unregulated'], 2)
yint1 = round(stats1.loc['int','Regulated'], 2)
yint2 = round(stats1.loc['int','Unregulated'], 2)
pval1 = round(stats1.loc['p_val', 'Regulated'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
ds.plot(ax=ax,marker='o', ls='', label=betterlabels)
ax.set_title(data_type)
plt.figtext(0.95, 0.4, 'Regulated equation: y= '+str(m1)+'x + '+str(yint1))
plt.figtext(0.96, 0.35, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.6, 'Unregulated equation: y= '+str(m2)+'x + '+str(yint2))
plt.figtext(0.96, 0.55, 'p-value = ' + str(pval2))
ax.legend()
plt.savefig(outputpath+'Stats/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/'+Name+'.csv')

# == For Deep wells ==
ds = wdc1
data_type = "Deep Wells"
betterlabels = ['Regulated','Unregulated'] 
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)      
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()


stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
#xf1 = pd.to_datetime(xf1)
m1 = round(stats1.loc['slope','Regulated'], 2)
m2 = round(stats1.loc['slope','Unregulated'], 2)
yint1 = round(stats1.loc['int','Regulated'], 2)
yint2 = round(stats1.loc['int','Unregulated'], 2)
pval1 = round(stats1.loc['p_val', 'Regulated'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
f.plot(ax=ax,marker='o', ls='', label=betterlabels)
ax.set_title(data_type)
plt.figtext(0.95, 0.4, 'Regulated equation: y= '+str(m1)+'x + '+str(yint1))
plt.figtext(0.96, 0.35, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.6, 'Unregulated equation: y= '+str(m2)+'x + '+str(yint2))
plt.figtext(0.96, 0.55, 'p-value = ' + str(pval2))
ax.legend()
plt.savefig(outputpath+'Stats/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/'+Name+'.csv')

# %% 2. For New Wells - By water category
ds = new_wells_watercat
data_type = "New Wells - Water Access"
betterlabels = ['CAP','Unregulated Groundwater','Mixed GW/SW','Regulated Groundwater','Surface Water'] 
min_yr = 2003
mx_yr = 2019
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

# -- For Multiple years --
# Name = "Linear Regression during Drought years for " + data_type
# wetyrs = [2005, 2008, 2009, 2010, 2016, 2017, 2019]
# dryyrs = [2002, 2003, 2004, 2006, 2007, 2011, 2012, 2013, 2014, 2015, 2018]
# #f = ds[(ds.index == wetyrs)]

# f = pd.DataFrame()
# for i in dryyrs:
#         wut = ds[(ds.index == i)]
#         f = f.append(wut)
# # print(f)
# columns = ds.columns
# column_list = ds.columns.tolist()
# ------------------------

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)
        
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()

stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','CAP'], 2)
m2 = round(stats1.loc['slope','Unregulated Groundwater'], 2)
m3 = round(stats1.loc['slope','Mixed GW/SW'], 2)
m4 = round(stats1.loc['slope','Regulated Groundwater'], 2)
m5 = round(stats1.loc['slope','Surface Water'], 2)
yint1 = round(stats1.loc['int','CAP'], 2)
yint2 = round(stats1.loc['int','Unregulated Groundwater'], 2)
yint3 = round(stats1.loc['int','Mixed GW/SW'], 2)
yint4 = round(stats1.loc['int','Regulated Groundwater'], 2)
yint5 = round(stats1.loc['int','Surface Water'], 2)
pval1 = round(stats1.loc['p_val', 'CAP'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated Groundwater'], 4)
pval3 = round(stats1.loc['p_val', 'Mixed GW/SW'], 4)
pval4 = round(stats1.loc['p_val', 'Regulated Groundwater'], 4)
pval5 = round(stats1.loc['p_val', 'Surface Water'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2
yf3 = (m3*xf)+yint3
yf4 = (m4*xf)+yint4
yf5 = (m5*xf)+yint5


fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
ax.plot(xf1, yf3,"-.",color='grey', lw=1)
ax.plot(xf1, yf4,"-.",color='grey', lw=1)
ax.plot(xf1, yf5,"-.",color='grey', lw=1)

f.plot(ax=ax,marker='o', ls='', label=betterlabels)
# ax.set_xlim(min_yr, mx_yr)
ax.set_title(data_type)
plt.figtext(0.95, 0.5, 'CAP equation: y = '+str(m1)+'x + '+str(yint1))
plt.figtext(0.98, 0.45, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.4, 'Unreg GW equation: y = '+str(m2)+'x + '+str(yint2))
plt.figtext(0.98, 0.35, 'p-value = ' + str(pval2))
plt.figtext(0.95, 0.3, 'Mix equation: y = '+str(m3)+'x + '+str(yint3))
plt.figtext(0.98, 0.25, 'p-value = ' + str(pval3))
plt.figtext(0.95, 0.2, 'Reg GW (No_CAP) equation: y = '+str(m4)+'x + '+str(yint4))
plt.figtext(0.98, 0.15, 'p-value = ' + str(pval4))
plt.figtext(0.95, 0.1, 'SW equation: y = '+str(m5)+'x + '+str(yint5))
plt.figtext(0.98, 0.05, 'p-value = ' + str(pval5))

ax.legend(loc = [1.065, 0.55])
plt.savefig(outputpath+'Stats/Water_CAT/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/Water_CAT/'+Name+'.csv')

# 3. Well Depths by Water Access
# == For Shallow ==
ds = wdc3
data_type = "Shallow Wells - Water Access"
betterlabels = ['CAP','Unregulated Groundwater','Mixed GW/SW','Regulated Groundwater','Surface Water'] 
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()

stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','CAP'], 2)
m2 = round(stats1.loc['slope','Unregulated Groundwater'], 2)
m3 = round(stats1.loc['slope','Mixed GW/SW'], 2)
m4 = round(stats1.loc['slope','Regulated Groundwater'], 2)
m5 = round(stats1.loc['slope','Surface Water'], 2)
yint1 = round(stats1.loc['int','CAP'], 2)
yint2 = round(stats1.loc['int','Unregulated Groundwater'], 2)
yint3 = round(stats1.loc['int','Mixed GW/SW'], 2)
yint4 = round(stats1.loc['int','Regulated Groundwater'], 2)
yint5 = round(stats1.loc['int','Surface Water'], 2)
pval1 = round(stats1.loc['p_val', 'CAP'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated Groundwater'], 4)
pval3 = round(stats1.loc['p_val', 'Mixed GW/SW'], 4)
pval4 = round(stats1.loc['p_val', 'Regulated Groundwater'], 4)
pval5 = round(stats1.loc['p_val', 'Surface Water'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2
yf3 = (m3*xf)+yint3
yf4 = (m4*xf)+yint4
yf5 = (m5*xf)+yint5

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
ax.plot(xf1, yf3,"-.",color='grey', lw=1)
ax.plot(xf1, yf4,"-.",color='grey', lw=1)
ax.plot(xf1, yf5,"-.",color='grey', lw=1)

f.plot(ax=ax,marker='o', ls='', label=betterlabels)
# ax.set_xlim(min_yr, mx_yr)
ax.set_title(data_type)
plt.figtext(0.95, 0.5, 'CAP equation: y = '+str(m1)+'x + '+str(yint1))
plt.figtext(0.98, 0.45, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.4, 'Unreg GW equation: y = '+str(m2)+'x + '+str(yint2))
plt.figtext(0.98, 0.35, 'p-value = ' + str(pval2))
plt.figtext(0.95, 0.3, 'Mix equation: y = '+str(m3)+'x + '+str(yint3))
plt.figtext(0.98, 0.25, 'p-value = ' + str(pval3))
plt.figtext(0.95, 0.2, 'Reg GW (No_CAP) equation: y = '+str(m4)+'x + '+str(yint4))
plt.figtext(0.98, 0.15, 'p-value = ' + str(pval4))
plt.figtext(0.95, 0.1, 'SW equation: y = '+str(m5)+'x + '+str(yint5))
plt.figtext(0.98, 0.05, 'p-value = ' + str(pval5))

ax.legend(loc = [1.065, 0.55])
plt.savefig(outputpath+'Stats/Water_CAT/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/Water_CAT/'+Name+'.csv')

# == For Midrange ==
ds = wdc2
data_type = "Midrange Wells - Water Access"
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)
        
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()

stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','CAP'], 2)
m2 = round(stats1.loc['slope','Unregulated Groundwater'], 2)
m3 = round(stats1.loc['slope','Mixed GW/SW'], 2)
m4 = round(stats1.loc['slope','Regulated Groundwater'], 2)
m5 = round(stats1.loc['slope','Surface Water'], 2)
yint1 = round(stats1.loc['int','CAP'], 2)
yint2 = round(stats1.loc['int','Unregulated Groundwater'], 2)
yint3 = round(stats1.loc['int','Mixed GW/SW'], 2)
yint4 = round(stats1.loc['int','Regulated Groundwater'], 2)
yint5 = round(stats1.loc['int','Surface Water'], 2)
pval1 = round(stats1.loc['p_val', 'CAP'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated Groundwater'], 4)
pval3 = round(stats1.loc['p_val', 'Mixed GW/SW'], 4)
pval4 = round(stats1.loc['p_val', 'Regulated Groundwater'], 4)
pval5 = round(stats1.loc['p_val', 'Surface Water'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2
yf3 = (m3*xf)+yint3
yf4 = (m4*xf)+yint4
yf5 = (m5*xf)+yint5

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
ax.plot(xf1, yf3,"-.",color='grey', lw=1)
ax.plot(xf1, yf4,"-.",color='grey', lw=1)
ax.plot(xf1, yf5,"-.",color='grey', lw=1)

f.plot(ax=ax,marker='o', ls='', label=betterlabels)
# ax.set_xlim(min_yr, mx_yr)
ax.set_title(data_type)
plt.figtext(0.95, 0.5, 'CAP equation: y = '+str(m1)+'x + '+str(yint1))
plt.figtext(0.98, 0.45, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.4, 'Unreg GW equation: y = '+str(m2)+'x + '+str(yint2))
plt.figtext(0.98, 0.35, 'p-value = ' + str(pval2))
plt.figtext(0.95, 0.3, 'Mix equation: y = '+str(m3)+'x + '+str(yint3))
plt.figtext(0.98, 0.25, 'p-value = ' + str(pval3))
plt.figtext(0.95, 0.2, 'Reg GW (No_CAP) equation: y = '+str(m4)+'x + '+str(yint4))
plt.figtext(0.98, 0.15, 'p-value = ' + str(pval4))
plt.figtext(0.95, 0.1, 'SW equation: y = '+str(m5)+'x + '+str(yint5))
plt.figtext(0.98, 0.05, 'p-value = ' + str(pval5))

ax.legend(loc = [1.065, 0.55])
plt.savefig(outputpath+'Stats/Water_CAT/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/Water_CAT/'+Name+'.csv')

# == For Deep wells ==
ds = wdc1
data_type = "Deep Wells - Water Access"
Name = str(min_yr) + " to " + str(mx_yr) + " Linear Regression for " + data_type
print(Name)

f = ds[(ds.index >= min_yr) & (ds.index <= mx_yr)]
columns = ds.columns
column_list = ds.columns.tolist()

stats = pd.DataFrame()
# for i in range(1, 12, 1):
for i in column_list:
        df = f[i]
        #print(df)
        y=np.array(df.values, dtype=float)
        x=np.array(pd.to_datetime(df).index.values, dtype=float)
        slope, intercept, r_value, p_value, std_err =sp.linregress(x,y)
        # print('Georegion Number: ', i, '\n', 
        #        'slope = ', slope, '\n', 
        #        'intercept = ', intercept, '\n', 
        #        'r^2 = ', r_value, '\n', 
        #        'p-value = ', p_value, '\n', 
        #        'std error = ', std_err)      
        stats = stats.append({'slope': slope, 
                              'int':intercept, 
                              'rsq':r_value*r_value, 
                              'p_val':p_value, 
                              'std_err':std_err, 
                              'mean': np.mean(y),
                              'var': np.var(y),
                              'sum': np.sum(y)
                              },
                              ignore_index=True)
        # xf = np.linspace(min(x),max(x),100)
        # xf1 = xf.copy()
        # xf1 = pd.to_datetime(xf1)
        # yf = (slope*xf)+intercept
        # fig, ax = plt.subplots(1, 1)
        # ax.plot(xf1, yf,label='Linear fit', lw=3)
        # df.plot(ax=ax,marker='o', ls='')
        # ax.set_ylim(max(y),0)
        # ax.legend()


stats.index = betterlabels
stats1 = stats.transpose()
print(stats1)

# -- Data visualization --
xf = np.linspace(min(x),max(x),100)
xf1 = xf.copy()
m1 = round(stats1.loc['slope','CAP'], 2)
m2 = round(stats1.loc['slope','Unregulated Groundwater'], 2)
m3 = round(stats1.loc['slope','Mixed GW/SW'], 2)
m4 = round(stats1.loc['slope','Regulated Groundwater'], 2)
m5 = round(stats1.loc['slope','Surface Water'], 2)
yint1 = round(stats1.loc['int','CAP'], 2)
yint2 = round(stats1.loc['int','Unregulated Groundwater'], 2)
yint3 = round(stats1.loc['int','Mixed GW/SW'], 2)
yint4 = round(stats1.loc['int','Regulated Groundwater'], 2)
yint5 = round(stats1.loc['int','Surface Water'], 2)
pval1 = round(stats1.loc['p_val', 'CAP'], 4)
pval2 = round(stats1.loc['p_val', 'Unregulated Groundwater'], 4)
pval3 = round(stats1.loc['p_val', 'Mixed GW/SW'], 4)
pval4 = round(stats1.loc['p_val', 'Regulated Groundwater'], 4)
pval5 = round(stats1.loc['p_val', 'Surface Water'], 4)

yf1 = (m1*xf)+yint1
yf2 = (m2*xf)+yint2
yf3 = (m3*xf)+yint3
yf4 = (m4*xf)+yint4
yf5 = (m5*xf)+yint5

fig, ax = plt.subplots(1, 1)
ax.plot(xf1, yf1,"-.",color='grey',label='Linear Trendline', lw=1)
ax.plot(xf1, yf2,"-.",color='grey', lw=1)
ax.plot(xf1, yf3,"-.",color='grey', lw=1)
ax.plot(xf1, yf4,"-.",color='grey', lw=1)
ax.plot(xf1, yf5,"-.",color='grey', lw=1)

f.plot(ax=ax,marker='o', ls='', label=betterlabels)
# ax.set_xlim(min_yr, mx_yr)
ax.set_title(data_type)
plt.figtext(0.95, 0.5, 'CAP equation: y = '+str(m1)+'x + '+str(yint1))
plt.figtext(0.98, 0.45, 'p-value = ' + str(pval1))
plt.figtext(0.95, 0.4, 'Unreg GW equation: y = '+str(m2)+'x + '+str(yint2))
plt.figtext(0.98, 0.35, 'p-value = ' + str(pval2))
plt.figtext(0.95, 0.3, 'Mix equation: y = '+str(m3)+'x + '+str(yint3))
plt.figtext(0.98, 0.25, 'p-value = ' + str(pval3))
plt.figtext(0.95, 0.2, 'Reg GW (No_CAP) equation: y = '+str(m4)+'x + '+str(yint4))
plt.figtext(0.98, 0.15, 'p-value = ' + str(pval4))
plt.figtext(0.95, 0.1, 'SW equation: y = '+str(m5)+'x + '+str(yint5))
plt.figtext(0.98, 0.05, 'p-value = ' + str(pval5))

ax.legend(loc = [1.065, 0.55])
plt.savefig(outputpath+'Stats/Water_CAT/'+Name, bbox_inches = 'tight')
stats1.to_csv(outputpath+'Stats/Water_CAT/'+Name+'.csv')
